---
title: 'IGN Data: Applying Statistics'
author: "by Ellen A. Savoye"
output:
  html_document:
    df_print: paged
---

Over the last 20 years, a plethora of video games have been released in an ever growing market of gaming consoles. Given the diversity, I would like to determine if, by year and over the years, there is a particular console that is the most popular by use and by average game rating. In addition, I would like to determine if, by year and over the years within reason, there is a particular video game genre that is heralded as the favorite by rating and amount of games within that genre with a positive rating.

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(echo=TRUE, error=FALSE)
```

#Loading the packages and the dataset
```{r message = FALSE}
#For visualization
library(ggplot2)
library(plotly)

#For data manipulation
library(readr)
library(dplyr)
library(tidyr)
library(rmarkdown)
library(lubridate)
library(knitr)

#Word cloud
library(tidytext)
library(reshape2)
library(wordcloud)

```

```{r Library_load}
IGN_data <- read.csv("ign_clean.csv")

```

```{r}
summary(IGN_data)
```
 
By looking at `glimpse` we already know that, but you can also check dimension to check number of rows and columns and column names with `dim` and `names` functions.
```{r}
dim(IGN_data)
names(IGN_data)
```

I will finish the first exploration with that functions. We will go soon more deeply in particular column attributes. Now, after looking at the data I made a list of few comments to be checked and probably cleaned up.

**Clean up tasks**:

* X1- This column contains id number. I won't be using id column in further analysis so that column can be removed

* url- This column also won't be in use in this report

* year, month, day- Date is handled in separate columns, it will be transformed to one column and changed to date type

* score_phrase- This column seems to have factor variables- to be checked

* editors_choice- column for sure contains factor variables


#Clean up
## Remove unuseful columns
```{r}
IGN_data<- IGN_data[,-c(1,4)]
```

## Unite *date* columns and change format
```{r}
IGN_data<- IGN_data %>% 
  unite(date, release_day, release_month, release_year, sep="/") 

IGN_data$date<- as.Date(IGN_data$date,"%d/%m/%Y")
glimpse(IGN_data)
```

##Transform *score_phrase* and *editors_choice* to factor {.tabset .tabset-fade}

###Score phrase {-}
```{r}
unique(IGN_data$score_phrase)
```
```{r}
IGN_data$score_phrase<- as.factor(IGN_data$score_phrase)
```

###Editors_choice {-}
```{r}
unique(IGN_data$editors_choice)
```

```{r}
IGN_data$editors_choice<- as.factor(IGN_data$editors_choice)
```

###Check {-}
```{r}
glimpse(IGN_data)
```

The dataset looks much cleaner now. When this step is ended it is time to go more deeply into the data. Although it is now seen what type of data we have, there is still no information about the columns content, especially games genre and relations between columns. Little visualisation would imagine some of them.

#Explore the data 

## Score_phrase
We've already found out that it represent factor variables and also can name it. Let's repeat their names and check how many games are in each score phrase. I will use `plot_ly` function. I am still learning all the opportunities of that huge package perfect for any visualisation.

```{r}
#Score phrases:
levels(IGN_data$score_phrase)

IGN_data %>% 
  count(score_phrase) %>% 
  plot_ly(x = ~score_phrase, y = ~n) %>% 
  add_bars()

```

Doesn't show much especially when score_phrase is not arrange correctly- so from most negative to most positive or vice versa

```{r}
#I will arrange a bit the columns from positive to negative score phrase as I supposed they should be. 
order<- c("Disaster","Painful","Awful","Unbearable","Bad","Mediocre","Okay","Good","Great","Amazing","Masterpiece")

IGN_data$score_phrase<- ordered(IGN_data$score_phrase, levels = order)

IGN_data %>% 
  count(score_phrase) %>% 
  plot_ly(x = ~score_phrase, y = ~n) %>% 
  add_bars()


```

Tend is visible growing. Comparing well reviewed games to negatively reviewed one the proportion is big. Looking at the chart for the first time I saw big proportion of *Masterpiece* and *Disaster* games, but when looking for the second one I saw there is not so few negative score phrases, there are more than 2300 games. 

Looking at the chart it is also truly seen than reviewers do not use extreme phrase scores very often either *Masterpiece* or *Disaster*. Let's see which games have that honour to get so many maximum scores and Masterpiece score_phrase (Output of 30 records):

```{r results='asis'}
IGN_data<- arrange(IGN_data, desc(date)) 

masterpiece<- IGN_data[,-c(3,7)] %>% 
  filter(score_phrase == "Masterpiece" ) %>% 
  unique()
  
kable(masterpiece[1:30, ], caption= "Masterpiece score_phrase records")
```

Grand Theft Auto IV and The Last of us are in the right place. But where is my favourite and phenomenal The Witcher series. I feel little disappointed with the dataset. Also do not find anything that could be named masterpiece in Tormado Mania, Pokemon and Sonic games. It is a pity that the dataset does not contain how many votes particular game had, because based on that amount the mean score and score phrase are granted.

Let's look at *Disaster* games
```{r}
disaster<- IGN_data[,-c(3,7)] %>% 
  filter(score_phrase == "Disaster" ) %>% 
  unique()
  
kable(disaster[1:10, ], caption= "Disaster score_phrase records")
```


It seems that "Masterpiece" score_phrase was reserved for games with score equal to 10 and Disaster for score below 1. What interest me a lot is how many *Masterpiece* games was in years and how it was changing via time

```{r}
IGN_data %>% 
  filter(score_phrase == "Masterpiece") %>% 
  mutate(year= year(date)) %>% 
  count(year) %>% 
  plot_ly(x = ~year, y = ~n) %>% 
  add_bars()

```

That's surprising... although games can be done more quickly, sometimes without that *putted heart* in process of doing it they are getting better and more often we are keen to name them a *Masterpiece*.. or maybe we are just more positive and less demanding ?? Technology and how the graphic was improved can also be the purpose.

Lets do the same with the rest of the score_phrases
```{r}
IGN_data_score_phrase<- IGN_data %>% 
  mutate(year= year(date)) %>% 
  count(year, score_phrase)


ggplot(IGN_data_score_phrase, aes(year, n)) +
geom_col(show.legend = FALSE) +
facet_wrap(~score_phrase, nrow=5, scales = "free")
```

Looks great. I see that there is something strange in year on *Disaster* chart but that is because of separating year from date, so it is no in date format any more. That's why we can see that there are year's halves on the plot. What first come to my mind is to transform it to factor so the year will become be a level but if you would try you will see that all the years will automatically appear on the axis and the chart wont be clear any more. 

Plotting it in that form may not be so accurate as looking at it separately but on quick glance of it is seen that most of them have similar decreasing trend or do not have any trend.

One last chance to check score_phrase trend would be gathering negative one in one chart. As negative I understand *Disaster*, *Painful*, *Awful*, *Unbearable*, and *Bad*.

```{r}
IGN_data %>% 
  filter(score_phrase == c("Disaster","Painful","Awful","Unbearable","Bad")) %>% 
  mutate(year= year(date)) %>% 
  count(year) %>% 
  plot_ly(x = ~year, y = ~n) %>% 
  add_bars()
```

Woohoo the trend of negative games is visibly strongly decreasing. Great news, moreover there more Masterpiece games. 

Have you spotted something like **golden year** in games history between 2005 and 2010 ? Lets focus on that years and find the golden one (so with maximum count) for every phrase


```{r}

a<- summarize(group_by(IGN_data_score_phrase, score_phrase), n= max(n))
total<- merge(a,IGN_data_score_phrase, by= c("score_phrase","n"))


ggplot(total, aes(score_phrase, fill= as.factor(year)))+ 
  geom_bar() +
  theme(axis.text.x = element_text(angle = 40, hjust = 1))
  
```

This graph is confessing that there was a *gold year* and it was year 2008. Why? Go to date bookmark.


## Score
After analysing the score_phrases we can supposed that they are somehow related. What I mean is that Disaster correspond to some average score. Let's investigate what average score was connected to which score_phrase

```{r results='asis'}
score1<- IGN_data %>% 
  group_by(score_phrase) %>% 
  mutate( mean_score= mean(score)) %>% 
  count(score_phrase, mean_score)

kable(score1)
```


Hah, seems like my levels was not corrected arranged, as you can see *Unbearable* should be after *Painful*. I will quickly change it.

```{r}
order<- c("Disaster","Unbearable","Painful","Awful","Bad","Mediocre","Okay","Good","Great","Amazing","Masterpiece")
IGN_data$score_phrase<- ordered(IGN_data$score_phrase, levels = order)
```

In advance we can see how many records are in different score_phrase and that rate is changing by about one point. 

## Platform

First let's see unique platforms the dataset contains
```{r}
unique(IGN_data$platform)
```

Wow, quite a lot of them. Now I would like to see the first and the last platform according to date

```{r results='asis'}
#Min
min<- IGN_data %>% 
  filter(date== min(date)) %>% 
  count(platform)
kable(min)


#Max
max<- IGN_data %>% 
  filter(date== max(date)) %>% 
  count(platform)
kable(max)
```

Something strange that Xbox is the first platform in the dataset. When we check:
```{r}
min(IGN_data$date)
```

clearly it is seen that it is the default one. It will for super affect on further charts if won't be changed. If there was bit more information (Xbox360 is not so unique platform) we could estimate the year or even try to predict from built model. For now I decided to delete this row. First we need to know the row number (column is number 7)

```{r}
look.for<- min(IGN_data$date)
IGN_data<- IGN_data[! IGN_data$date %in% look.for, ]

#Check
min(IGN_data$date)

#Woohoo, now let's show proper platforms, the oldest one

min<- IGN_data %>% 
  filter(date== min(date)) %>% 
  count(platform)
kable(min)
```


Now I can correlate games score_phrase with platform (top 10)

```{r message=FALSE}
top_10<- IGN_data %>%
  count(platform, sort=TRUE) %>% 
  head(10)


IGN_data %>% 
  filter(platform == top_10$platform) %>% 
  ggplot(aes(x= ordered(platform,top_10$platform), fill= score_phrase)) + geom_bar() + theme(axis.text.x = element_text(angle = 40, hjust = 1)) +labs(x= "Top 10 platforms")
```


## Genre

Ok, I suppose there a quite a lot of unique once, just quickly check this one:
```{r}
vec<- unique(IGN_data$genre)
str(vec)

# Ohh 113 that is a lot, but how you probably saw the genre is duplicated when connected to other
```

```{r message=FALSE, warning=FALSE}
columns<- c("genre", "score_phrase")
IGN_data_second<- IGN_data[,columns]

#I have an idea to deal with bigrams of genre, check this:
IGN_data_second<- IGN_data_second %>% 
  separate(genre, c("genre1", "genre2"), sep = ",")
#Genres are separated now, lets save second one with connected score_phrase, remove NA values and join to existing one. I will IGN_dataore that score value for one game would be doubled.

columns2<- c("genre2", "score_phrase")
IGN_data_third<- IGN_data_second[, columns2]
IGN_data_third<- IGN_data_third[complete.cases(IGN_data_third), ]

columns3<- c("genre1", "score_phrase")
IGN_data_second<- IGN_data_second[, columns3]
colnames(IGN_data_second)<- c("genre", "score_phrase")
colnames(IGN_data_third)<- c("genre", "score_phrase")

final_IGN_data<- rbind(IGN_data_second, IGN_data_third)
str(final_IGN_data)
```

Time to summarise it with the chart: pay attention how action games run off other genres, also look at those great labels on the chart while zooming one score phrase.
```{r}
#Unique genres now
vec<- unique(final_IGN_data$genre)
str(vec)

#Select top 10 now
top_10_genre<- final_IGN_data %>% 
  count(genre, sort=TRUE) %>% 
  top_n(10)


#Chart
vector<- top_10_genre$genre
final_IGN_data %>% 
  filter(genre == vector) %>% 
  group_by(genre) %>% 
  count(genre, score_phrase) %>% 
  plot_ly(x = ~genre, y = ~n, type = 'bar', color = ~score_phrase) 
  
```

## Date

Hey, we have seen that 2008 was a special year. Are you interested what was special that period? Maybe some new technology went on the market? It could be a good start so let's select the year each technology was released and then filter selected year.

```{r}
b<- summarize(group_by(IGN_data, platform), year= min(year(date)))
b %>% 
  filter(year == "2008")
```

As for my knowledge all of them except for iPhone that now is celebrating his 10th birthday, was released before 2000, some of them even before 1980. Is iPhone the purpose? It will be good to check if how many of games released in 2008 was for iPhone

```{r}
#total games in 2008
games_2008<- IGN_data %>% mutate(year = year(date)) %>% filter( year == "2008") 
games_2008 %>% count(year)
```
```{r}
games_2008 %>% filter(platform == "iPhone") %>% count(platform)
```
Not so big.. that obviusly wasn't a purpose of producing more games. 


#Trend charts
Every year ratio of genres for each score_phrase is changing. Are you interested in what direction is it going? I will work on selected, let's take four, score_phrases to prepare one chart gathering year- genre trend. 

Let's take: Amazing, Awful, Okay, Bad. There are quite a lot of them in the dataset so the line chart will be more smooth than for *Mastepiece* score_phrase


```{r}
choosed_columns<- c("score_phrase", "genre", "date")

selected_data<- IGN_data[,choosed_columns] %>% 
  filter(score_phrase == c("Amazing", "Awful", "Okay", "Bad")) %>% 
  mutate(year= year(date))

selected_data<- selected_data[,-3]
```

Just like for the bigrams of genre lets repeat those steps
```{r}
selected_data<- selected_data %>% 
  separate(genre, c("genre1", "genre2"), sep = ",")

columns_a<- c("score_phrase", "genre2", "year")
selected1<- selected_data[, columns_a]
selected1<- selected1[complete.cases(selected1), ]

columns_b<- c("score_phrase", "genre1", "year")
selected2<- selected_data[, columns_b]
colnames(selected1)<- c("score_phrase", "genre", "year")
colnames(selected2)<- c("score_phrase", "genre", "year")

final_masterdata<- rbind(selected2, selected1)
str(final_masterdata)

```

I will create `count` table to sum up number of games in particular year. Than after checking count of games in different group in year (I mean score_phrase and genre) the ratio column can be calculated.
```{r}
count<- final_masterdata %>% 
  group_by(year) %>% 
  count(score_phrase, year)

final_masterdata<- final_masterdata %>% 
  group_by(year) %>% 
  count(score_phrase, year, genre)

final_masterdata<- merge(final_masterdata, count, by=c("year", "score_phrase"))
final_masterdata<- final_masterdata %>% 
  mutate(ratio = n.x/n.y)

```

Final and my favourite part: let's start plotting
```{r}
#Action
final_masterdata %>% 
  filter(genre == "Action") %>% 
  ggplot(aes(x=year, y=ratio, group= score_phrase, colour=score_phrase)) + geom_line()
```

Doesn't show much, right? Maybe separating it would bring more information

```{r}
#Action
final_masterdata %>% 
  filter(genre == "Action") %>% 
  ggplot(aes(x=year, y=ratio)) + geom_line() +facet_grid(score_phrase ~.)
```

#Quick play with word cloud
Hey, just to show you how fun and powerful wordcloud can be I will show you few examples. We have score phrases that are perfect for that. First, lets show according to letter measures, size of *score_phrases* groups

```{r}
IGN_data %>% 
  count(score_phrase) %>% 
  with(wordcloud(score_phrase, n, max.words= 50))
```

I would like to check if that proportion will change for action genre, while this is the biggest group 

```{r}
IGN_data %>% 
  filter(genre == "Action") %>% 
  count(score_phrase) %>% 
  with(wordcloud(score_phrase, n, max.words= 50))
```

```{r}
ggplot(IGN_data,aes(x=reorder(genre_group,genre_group,function(x)-length(x)))) + geom_bar(aes(fill=platform_group),color='black') + theme(axis.text.x = element_text(angle=90, hjust=1)) + xlab('Genre') + theme(legend.title=element_blank()) 
```

```{r}
IGN_data %>% distinct(platform_group) %>% 
  arrange(platform_group)

ggplot(data=subset(IGN_data,platform_group %in% c('Xbox','PlayStation','Nintendo')),aes(x=factor(release_year),y=score)) + geom_boxplot(aes(fill=(platform_group))) + theme(legend.position=c(.1, .2)) + xlab('Year') + ylab('score')+ theme(legend.title=element_blank()) 
```


